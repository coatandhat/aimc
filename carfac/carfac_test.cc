//
//  carfac_test.cc
//  CARFAC Open Source C++ Library
//
//  Created by Alex Brandmeyer on 5/22/13.
//
// This C++ file is part of an implementation of Lyon's cochlear model:
// "Cascade of Asymmetric Resonators with Fast-Acting Compression"
// to supplement Lyon's upcoming book "Human and Machine Hearing"
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "carfac.h"

#include <fstream>
#include <string>
#include <vector>

#include "gtest/gtest.h"

#include "agc.h"
#include "car.h"
#include "carfac_output.h"
#include "common.h"
#include "ihc.h"

using std::deque;
using std::ifstream;
using std::ofstream;
using std::string;
using std::vector;

// Location of the text files produced by 'CARFAC_GenerateTestData.m' for
// comparing the ouput of the Matlab implementation with the one used here.
static const char* kTestSourceDir = "./test_data/";

// Writes the CARFAC NAP output to a text file.
void WriteNAPOutput(const CARFACOutput& output, const string& filename,
                    int ear) {
  string fullfile = kTestSourceDir + filename;
  ofstream ofile(fullfile.c_str());
  int32_t num_timepoints = output.nap().size();
  int channels = output.nap()[0][0].size();
  if (ofile.is_open()) {
    for (int32_t i = 0; i < num_timepoints; ++i) {
      for (int j = 0; j < channels; ++j) {
        ofile << output.nap()[i][ear](j);
        if (j < channels - 1) {
          ofile << " ";
        }
      }
      ofile << "\n";
    }
  }
  ofile.close();
}

// Reads a size rows vector of size columns Container objects from a
// multi-column text file generated by the Matlab version of CARFAC.
template <typename Container = ArrayX, bool ColMajor = true>
vector<Container> Load2dTestData(const string& filename, const int rows,
                                 const int columns) {
  string fullfile = kTestSourceDir + filename;
  ifstream file(fullfile.c_str());
  vector<Container> output;
  if (ColMajor) {
    output.assign(rows, Container(columns));
  } else {
    output.assign(columns, Container(rows));
  }
  if (file.is_open()) {
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < columns; ++j) {
        if (ColMajor) {
          file >> output[i][j];
        } else {
          file >> output[j][i];
        }
      }
    }
  }
  file.close();
  return output;
}

// Reads a two dimensional vector of audio data from a text file
// containing the output of the Matlab wavread() function.
vector<vector<float>> Load2dAudioVector(string filename, int timepoints,
                                        int channels) {
  return Load2dTestData<vector<float>, false>(filename, timepoints, channels);
}

class CARFACTest : public testing::Test {
 protected:
  deque<vector<ArrayX>> LoadTestData(
      const string& basename, int n_timepoints, int n_ears, int n_ch) const {
    deque<vector<ArrayX>> test_data(n_timepoints, vector<ArrayX>(n_ears));
    for (int ear = 0; ear < n_ears; ++ear) {
      string filename = basename + std::to_string(ear + 1) + ".txt";
      vector<ArrayX> data = Load2dTestData(filename, n_timepoints, n_ch);
      for (int i = 0; i < n_timepoints; ++i) {
        test_data[i][ear] = data[i];
      }
    }
    return test_data;
  }

  void AssertCARFACOutputNear(const deque<vector<ArrayX>>& expected,
                              const deque<vector<ArrayX>>& actual,
                              int n_timepoints, int n_ears, int n_ch) const {
    for (int timepoint = 0; timepoint < n_timepoints; ++timepoint) {
      for (int ear = 0; ear < n_ears; ++ear) {
        for (int channel = 0; channel < n_ch; ++channel) {
          const float kPrecisionLevel = 1.0e-7;
          ASSERT_NEAR(expected[timepoint][ear](channel),
                      actual[timepoint][ear](channel),
                      kPrecisionLevel);
        }
      }
    }
  }

  CARParams car_params_;
  IHCParams ihc_params_;
  AGCParams agc_params_;
};

TEST_F(CARFACTest, BinauralData) {
  const int n_timepoints = 882;
  const int n_ears = 2;
  const int n_ch = 71;
  vector<vector<float>> sound_data =
      Load2dAudioVector("file_signal_binaural_test.txt", n_timepoints, n_ears);
  CARFAC carfac(n_ears, 22050, car_params_, ihc_params_, agc_params_);
  CARFACOutput output(true, true, false, false);
  const bool kOpenLoop = false;
  const int length = sound_data[0].size();
  carfac.RunSegment(sound_data, 0, length, kOpenLoop, &output);

  // TODO(ronw): Don't unconditionally overwrite files that are
  // checked in to the repository on every test run.
  WriteNAPOutput(output, "cpp_nap_output_1_binaural_test.txt", 0);
  WriteNAPOutput(output, "cpp_nap_output_2_binaural_test.txt", 1);

  deque<vector<ArrayX>> expected_nap =
      LoadTestData("binaural_test_nap", n_timepoints, n_ears, n_ch);
  AssertCARFACOutputNear(expected_nap, output.nap(),
                         n_timepoints, n_ears, n_ch);
  deque<vector<ArrayX>> expected_bm =
      LoadTestData("binaural_test_bm", n_timepoints, n_ears, n_ch);
  AssertCARFACOutputNear(expected_bm, output.bm(),
                         n_timepoints, n_ears, n_ch);
}

TEST_F(CARFACTest, LongBinauralData) {
  const int n_timepoints = 2000;
  const int n_ears = 2;
  const int n_ch = 83;
  vector<vector<float>> sound_data =
      Load2dAudioVector("file_signal_long_test.txt", n_timepoints, n_ears);
  CARFAC carfac(n_ears, 44100, car_params_, ihc_params_, agc_params_);
  CARFACOutput output(true, true, false, false);
  const bool kOpenLoop = false;
  const int length = sound_data[0].size();
  carfac.RunSegment(sound_data, 0, length, kOpenLoop, &output);

  // TODO(ronw): Don't unconditionally overwrite files that are
  // checked in to the repository on every test run.
  WriteNAPOutput(output, "cpp_nap_output_1_long_test.txt", 0);
  WriteNAPOutput(output, "cpp_nap_output_2_long_test.txt", 1);

  deque<vector<ArrayX>> expected_nap =
      LoadTestData("long_test_nap", n_timepoints, n_ears, n_ch);
  AssertCARFACOutputNear(expected_nap, output.nap(),
                         n_timepoints, n_ears, n_ch);
  deque<vector<ArrayX>> expected_bm =
      LoadTestData("long_test_bm", n_timepoints, n_ears, n_ch);
  AssertCARFACOutputNear(expected_bm, output.bm(),
                         n_timepoints, n_ears, n_ch);
}
